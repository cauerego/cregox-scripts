<script src="http://cdnjs.cloudflare.com/ajax/libs/masonry/3.3.0/masonry.pkgd.min.js"></script>
<script src="https://cdn.rawgit.com/desandro/imagesloaded/master/imagesloaded.pkgd.min.js"></script>
<script name="endless scrolling" author="cregox.com">
  // mostly based on script from foley at http://answers.squarespace.com/questions/17153/how-can-i-create-an-infinite-scroll-blog-on-the-developer-platform

  Y.use('node', function()
  {
    Y.on('domready', function()
    {
      Y.one('main#main').addClass('endless-scrolling');

      // prevent script from running in squarespace editor
      if (window.top.document !== window.document) return;

      // config
      var thumbSize = 300; //px
      var loadingMargin = 500; //px
      var parent = 'main#main .wrapper';
      var list = '.summary-item-list';
      var post = '.summary-item';

      // private
      var jsonCachedRequest = null;
      var YparentToAppend;
      var YnewItemToClone;
      var itemsLoaded = 0;
      var totalItemsCount = 0;// Static.SQUARESPACE_CONTEXT.collection.itemCount;
      var urlQuery = window.location.pathname;
      var stuffBottom;
      var YloadingIcon;
      var msnry;
      var layoutComplete = false;

      YparentToAppend = Y.one(parent).one('div');
      cacheAjaxRequest();

      setMouseHover(YparentToAppend);

      YloadingIcon = Y.one('a[href^="javascript:endlessScrollingLoading"]');

      // almost all styles set in this whole script need to be set here
      // to overwrite styles already set on the element before this
      YparentToAppend.all('.summary-item').setStyle('width', 'initial');
      
      YloadingIcon.one('img').setStyles({
        'bottom': '',
        'top': '',
        'left': '',
        'right': '',
        'width': '',
        'height': '',
        'position': ''
      }).addClass('endless-loading').ancestor().setStyle('text-align', 'center');
      YloadingIcon.one('div.image-block-wrapper').setStyle('padding-bottom', 0);
      Y.one(parent).append(YloadingIcon);
      
      YnewItemToClone = YparentToAppend.one('.summary-item-list .summary-item').cloneNode(true);
      YnewItemToClone.hide();
      itemsLoaded = YparentToAppend.one('.summary-item-list').all('.summary-item').size();

      Y.one(parent).setStyles({
        'background-color': '#e8edf3',
        'padding': '2em'
      });
      Y.one('footer#footer').hide().setStyles({
        'position': 'absolute',
        'bottom': 0,
        'left': '50px',
        'right': '50px'
      });

      loadMasonry(); loadMasonry(); // loading twice just works

      Y.on('scroll', function()
      {
        loadScreenImages();
        loadMasonry();
      }); // Y on scroll

      function loadMasonry ()
      {
        var container = document.querySelector(list);
        msnry = new Masonry( container,
        {
          'transitionDuration': 0,
          'gutter': 15,
          'itemSelector': '.summary-item',
          'isInitLayour': false
        });
        
        msnry.on( 'layoutComplete', function( laidOutItems )
        {
          YloadingIcon.one('img').hide();
          
          if (layoutComplete)
          {
            YloadingIcon.one('div.image-block-wrapper').setStyle('height', 'auto');
          }
          else
          {
            resetScrollingVars();
          }
          return true; // listen to event only once
        });
        imagesLoaded( container, function()
        {
          msnry.layout();
        });
      }

      function resetScrollingVars ()
      {
        Y.one('body').simulate('resize'); // adjust items in the columns
        
        var parentChild = parent + '>div';
        stuffBottom = Y.one(parentChild).get('clientHeight') + Y.one(parentChild).getY();
        
        var windowHeight = window.innerHeight
         || document.documentElement.clientHeight
         || document.body.clientHeight;
        var spaceHeight = windowHeight + window.scrollY;

        // measures distance from page top to content bottom
        // should be less than scrollY position
        if (spaceHeight + loadingMargin >= stuffBottom)
        {
          if (spaceHeight > stuffBottom)
          {
            var Yimg = YloadingIcon.one('img:not(.fixed)');
            if (Yimg) Yimg.addClass('fixed');
          }
          else
          {
            var Yimg = YloadingIcon.one('img.fixed');
            if (Yimg) Yimg.removeClass('fixed');
          }
//          createLayout();
        }
      }

      function createLayout ()
      {
        if (jsonCachedRequest === null || layoutComplete) return false;

        YloadingIcon.one('img').show();

        var json = jsonCachedRequest;

        for (var i = itemsLoaded; i < totalItemsCount; i++)
        {
          var YnewItem = YnewItemToClone.cloneNode(true).show();

          var YnewItemImg = YnewItem.one('img');
          YnewItemImg
            .setStyle('opacity', 1)
            .onload = function () {
              YnewItem.setStyles({
                'width': YnewItemImg.width +'px',
                'height': YnewItemImg.height +'px'
              });
              YnewItemImg.set('src', '');
              // set element with image size and prevent image from loading
            };

          var imgSrc = json.items[i].assetUrl +'?format='+ thumbSize +'w';
          YnewItemImg.set('src', imgSrc);
          YnewItemImg.set('data-src', imgSrc);


          YnewItem.one('a').set('href', json.items[i].fullUrl);
          YnewItem.one('.product-price span').setContent(
            (json.items[i].variants[0].price / 100).toFixed(2)
          );

          setMouseHover(YnewItem);
          YparentToAppend.one('.summary-item-list').append(YnewItem);
        }

//        YloadingIcon.remove(true);
        Y.one('footer#footer').show();
        layoutComplete = true;

        return true;
      } // function createLayout
      
      function loadScreenImages ()
      {
//        YloadingIcon.one('img').show();
        // only load images that are on screen
//        resetScrollingVars();
      } // function loadScreenImages

      function cacheAjaxRequest ()
      {
        if (jsonCachedRequest === null)
        {
          // ajax request
          Y.io('/shop?format=json', {
            on: {
              success: function (x, o) {
                try {
                  json = Y.JSON.parse(o.responseText);
                } catch (e) {
                  console.log("JSON Parse failed!");
                  return;
                }

                // when done loading json

                jsonCachedRequest = json;
                totalItemsCount = json.items.length;

                resetScrollingVars();

                createLayout();
                loadMasonry(); loadMasonry(); // loading twice just works
              }
            }
          });
        }
      } // function cacheAjaxRequest

      function setMouseHover (Ynode)
      {
        Ynode.all('.summary-item img').on('mouseenter', function(e)
        {
          e.currentTarget.transition(
            {
              duration:0.5,
              opacity:0.5
            });
        });
        Ynode.all('.summary-item img').on('mouseleave', function(e)
        {
          e.currentTarget.transition(
            {
              duration:0.5,
              opacity:1
            });
        });
      } // function setMouseHover

    }); // Y on DOMready
  }); // Y use node
</script>